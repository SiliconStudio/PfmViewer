// Portable float & float16 pfm/phm image viewer
// Copyright Silicon Studio K.K. 2023
// author: Vivien Oddou
// BSD License

#include <iostream>
#include <fstream>
#include <iterator>
#include <string_view>

#include <simd_routines.h>  // auto generated by ispc and located in the build folder (config from cmake custom target)

#include <nana/gui.hpp>
#include <nana/gui/widgets/label.hpp>
#include <nana/gui/widgets/button.hpp>
#include <nana/gui/widgets/group.hpp>
#include <nana/gui/widgets/picture.hpp>
#include <nana/gui/filebox.hpp>
#include <nana/gui/msgbox.hpp>
#include <nana/paint/graphics.hpp>


namespace fs = std::filesystem;
using std::vector;
using std::string_view;
using namespace nana;

struct pfm_header
{
    std::string magic;
    int w = 0, h = 0;
    float scale_endian;

    char get_magic2ndchar() const { return magic.length() >= 2 ? magic[1] : 0; }
    bool is_half() const { return tolower(get_magic2ndchar()) == 'h'; }
    bool is_mono() const { return islower(get_magic2ndchar()); }
    int num_channels() const { return is_mono() ? 1 : 3; }
    size_t calc_raw_size() const { return w * h * num_channels() * sizeof(float) / (is_half() ? 2 : 1); }
};

bool pending_data(std::istream& is)
{
    is.seekg(0, is.end);
    auto length = is.tellg();
    is.seekg(0, is.beg);
    return !(length < 0);
}

msgbox message(std::string const& title, msgbox::icon_t ico, msgbox::button_t btn)
{
    msgbox m({}, title, btn);
    m.icon(ico);
    return m;
}

// using uint8 in ispc causes performance warnings so we use int8 on -128,127 range
// this function is the remap
uint8_t stou(int8_t i)
{
    return uint8_t((int)i + 128);
}

//#include <windows.h>

int main(int argc, char* argv[])
{
    fs::path inpath;
    std::ifstream infile;
    std::istream* in = nullptr;

    //Sleep(10000);

    if ((argc >= 2 && argv[1][0] == '-') || pending_data(std::cin))  // input is piped on stdin?
        in = &std::cin;
    else if (argc <= 1)  // no command line -> open file dialog
    {
        filebox picker{nullptr, true};
        picker.title("Pick image file");
        picker.add_filter("Portable half map (.phm)", "*.phm");
        picker.add_filter("Portable float map (.pfm)", "*.pfm");
        vector<fs::path> paths = picker.show();
        if (!paths.empty())
            inpath = paths[0];
    }
    else if (argc >= 2)
        inpath = argv[1];

    if (!inpath.empty())
    {
        infile.open(inpath, std::ifstream::in | std::ifstream::binary);
        in = &infile;
    }

    if (!in || !*in) return 0; // no good input

    pfm_header pfm;
    *in >> pfm.magic >> pfm.w >> pfm.h >> pfm.scale_endian;

    std::cout << "magic:" << pfm.magic << " w:" << pfm.w << " h:" << pfm.h << " scale_endian: " << pfm.scale_endian << "\n";

    size_t alloc = pfm.calc_raw_size();
    if (alloc == 0)
    {
        (message("No data", msgbox::icon_information, msgbox::ok) << "Width and height are 0 or not found")();
        return 2;
    }
    if (alloc > 1'000'000'000)
    {
        (message("Calculated image size too large", msgbox::icon_error, msgbox::ok)
            << "More than 1GiB of data needed because of parsed width:" << pfm.w << " and height:" << pfm.h)();
        return 3;
    }

    vector<char> raw;
    raw.resize(alloc);

    std::cout << "about to read " << alloc << " bytes\n";
    in->ignore(1);  // jump the last \n after scale_endian
    freopen(nullptr, "rb", stdin);  // go in binary mode from here
    in->sync_with_stdio();
    // read bulk:
    in->read(raw.data(), alloc);

    if (auto cnt = in->gcount(); cnt != alloc)
        std::cout << "not enough data read (" << cnt << " instead of " << alloc << " expected)\n";
    else if (std::cin.rdbuf()->in_avail() > 0)
        std::cout << "remaining data not read " << std::cin.rdbuf()->in_avail() << "\n";

    vector<int8_t> rgb;
    rgb.resize(pfm.w * pfm.h * pfm.num_channels());
    if (pfm.is_half())
        ispc::ToneAllF16PixelsAndToGamma((uint16_t*)raw.data(), rgb.data(), raw.size() / 2, 1.f);
    else
        ispc::ToneAllF32PixelsAndToGamma((float*)raw.data(), rgb.data(), raw.size() / 4, 1.f);

    paint::graphics g(size(pfm.w, pfm.h));
    auto rgb_it = rgb.begin();
    if (pfm.num_channels() == 3)
        for (int y = 0; y < pfm.h; ++y)
            for (int x = 0; x < pfm.w; ++x)
            {
                g.set_pixel(x, y, {stou(*rgb_it), stou(*(rgb_it + 1)), stou(*(rgb_it + 2))});
                rgb_it += 3;
            }
    else
        for (int y = 0; y < pfm.h; ++y)
            for (int x = 0; x < pfm.w; ++x)
            {
                uint8_t bw{stou(*rgb_it)};
                g.set_pixel(x, y, {bw, bw, bw});
                ++rgb_it;
            }


    form   fm;                             // Our main window
    fm.caption("My first NANA demo");       // (with this title)
    place  fm_place{fm};                    // have automatic layout
    bool   really_quick{false};             // and a default behavior
    label  hello{fm,"Hello World"};         // We put a label on our window
    button btn{fm,"Quit"};                // and a button
    btn.tooltip("I will ask first");       // that show a tip upon mouse hover
    group  act{fm, "Actions"};            // Add a group of "options"
    act.add_option("Quick quickly")         // and two options that control quick behavior
        .events().click([&]() {   really_quick = true;
    btn.tooltip("Quick quickly");       });
    act.add_option("Ask first")
        .events().click([&]() {   really_quick = false;
    btn.tooltip("I will ask first");    });
    btn.events().click([&]()               // now the button know how to respond
                       {
                           if (!really_quick)     // not really quick !
                           {
                               msgbox m(fm, "Our demo", msgbox::yes_no);
                               m.icon(m.icon_question);
                               m << "Are you sure you want to quick?";
                               auto response = m();
                               if (response != m.pick_yes) return;   // return to the demo
                           }
                           API::exit();           // or really quick
                       });
    act.radio_mode(true);                   // Set "radio mode" (only one option selected)
    picture p{fm};
    drawing d{p};
    d.draw([&](paint::graphics& a_g)
           {
               a_g.bitblt(rectangle({0, 0}, a_g.size()), g, {0,0});
           });
    // let divide fm into fields to holds the other controls.
    // for example, let split fm into two fields separated by a movable vertical barre.
    fm_place.div("vertical <label margin=10>|70% <actions>");
    fm_place["label"] << hello << btn;        // and place the controls there
    fm_place["actions"] << act << p;
    fm_place.collocate();                      // and collocate all in place

    fm.show();
    exec();

    return 0;
}
