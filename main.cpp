// Portable float & float16 pfm/phm image viewer
// Copyright Silicon Studio K.K. 2023
// author: Vivien Oddou
// BSD License

#include <iostream>
#include <fstream>
#include <iterator>
#include <string_view>

#include <simd_routines.h>  // auto generated by ispc and located in the build folder (config from cmake custom target)

#include <nana/gui.hpp>
#include <nana/gui/widgets/label.hpp>
#include <nana/gui/widgets/button.hpp>
#include <nana/gui/widgets/group.hpp>
#include <nana/gui/filebox.hpp>
#include <nana/gui/msgbox.hpp>

namespace fs = std::filesystem;
using std::vector;
using std::string_view;
using namespace nana;

struct pfm_header
{
    std::string magic;
    int w = 0, h = 0;
    float scale_endian;

    char get_magic2ndchar() const { return magic.length() >= 2 ? magic[1] : 0; }
    bool is_half() const { return tolower(get_magic2ndchar()) == 'h'; }
    bool is_mono() const { return islower(get_magic2ndchar()); }
    int num_channels() const { return is_mono() ? 1 : 3; }
    size_t calc_raw_size() const { return w * h * num_channels() * sizeof(float) / (is_half() ? 2 : 1); }
};

bool pending_data(std::istream& is)
{
    is.seekg(0, is.end);
    auto length = is.tellg();
    is.seekg(0, is.beg);
    return !(length < 0);
}

msgbox message(std::string const& title, msgbox::icon_t ico, msgbox::button_t btn)
{
    msgbox m({}, title, btn);
    m.icon(ico);
    return m;
}

//#include <windows.h>

int main(int argc, char* argv[])
{
    fs::path inpath;
    std::ifstream infile;
    std::istream* in = nullptr;

    //Sleep(10000);

    if ((argc >= 2 && argv[1][0] == '-') || pending_data(std::cin))  // input is piped on stdin?
        in = &std::cin;
    else if (argc <= 1)  // no command line -> open file dialog
    {
        filebox picker{nullptr, true};
        picker.title("Pick image file");
        picker.add_filter("Portable half map (.phm)", "*.phm");
        picker.add_filter("Portable float map (.pfm)", "*.pfm");
        vector<fs::path> paths = picker.show();
        if (!paths.empty())
            inpath = paths[0];
    }
    else if (argc >= 2)
        inpath = argv[1];

    if (!inpath.empty())
    {
        infile.open(inpath, std::ifstream::in | std::ifstream::binary);
        in = &infile;
    }

    if (!in || !*in) return 0; // no good input

    pfm_header pfm;
    *in >> pfm.magic >> pfm.w >> pfm.h >> pfm.scale_endian;

    std::cout << "magic:" << pfm.magic << " w:" << pfm.w << " h:" << pfm.h << " scale_endian: " << pfm.scale_endian << "\n";

    size_t alloc = pfm.calc_raw_size();
    if (alloc == 0)
    {
        (message("No data", msgbox::icon_information, msgbox::ok) << "Width and height are 0 or not found")();
        return 2;
    }
    if (alloc > 1'000'000'000)
    {
        (message("Calculated image size too large", msgbox::icon_error, msgbox::ok)
            << "More than 1GiB of data needed because of parsed width:" << pfm.w << " and height:" << pfm.h)();
        return 3;
    }

    vector<char> raw;
    raw.resize(alloc);

    std::cout << "about to read " << alloc << " bytes\n";

    // go in binary mode from here
    freopen(nullptr, "rb", stdin);
    in->sync_with_stdio();
    *in >> std::noskipws;

    // read bulk
    in->read(raw.data(), alloc);

    if (auto cnt = in->gcount(); cnt != alloc)
        std::cout << "not enough data read (" << cnt << " instead of " << alloc << " expected)\n";
    else if (std::cin.rdbuf()->in_avail() > 0)
        std::cout << "remaining data not read " << std::cin.rdbuf()->in_avail() << "\n";

    form   fm;                             // Our main window
    fm.caption("My first NANA demo");       // (with this title)
    place  fm_place{fm};                    // have automatic layout
    bool   really_quick{false};             // and a default behavior
    label  hello{fm,"Hello World"};         // We put a label on our window
    button btn{fm,"Quit"};                // and a button
    btn.tooltip("I will ask first");       // that show a tip upon mouse hover
    group  act{fm, "Actions"};            // Add a group of "options"
    act.add_option("Quick quickly")         // and two options that control quick behavior
        .events().click([&]() {   really_quick = true;
    btn.tooltip("Quick quickly");       });
    act.add_option("Ask first")
        .events().click([&]() {   really_quick = false;
    btn.tooltip("I will ask first");    });
    btn.events().click([&]()               // now the button know how to respond
                       {
                           if (!really_quick)     // not really quick !
                           {
                               msgbox m(fm, "Our demo", msgbox::yes_no);
                               m.icon(m.icon_question);
                               m << "Are you sure you want to quick?";
                               auto response = m();
                               if (response != m.pick_yes) return;   // return to the demo
                           }
                           API::exit();           // or really quick
                       });
    act.radio_mode(true);                   // Set "radio mode" (only one option selected)
      // let divide fm into fields to holds the other controls.
      // for example, let split fm into two fields separated by a movable vertical barre.
    fm_place.div("vertical <label margin=10>|70% <actions>");
    fm_place["label"] << hello << btn;        // and place the controls there
    fm_place["actions"] << act;
    fm_place.collocate();                      // and collocate all in place
    fm.show();
    exec();

    static const size_t s = 4 * 3;
    float vin[s];
    int8_t vout[s];
    for (int i = 0; i < s; ++i)
        vin[i] = rand() / 5000.f;

    ispc::ToneAllPixels(vin, vout, s, 1.f);

    for (int i = 0; i < s; ++i)
        printf("%d: posttone(%f) = %d\n", i, vin[i], vout[i] + 128);

    return 0;
}
