// Portable float & float16 pfm/phm image viewer
// Copyright Silicon Studio K.K. 2023
// author: Vivien Oddou
// BSD License

#include <iostream>
#include <ios>
#include <fstream>
#include <iterator>
#include <string_view>
#include <algorithm>

#include <simd_routines.h>  // auto generated by ispc and located in the build folder (config from cmake custom target)

#include <nana/gui.hpp>
#include <nana/gui/widgets/label.hpp>
#include <nana/gui/widgets/button.hpp>
#include <nana/gui/widgets/group.hpp>
#include <nana/gui/widgets/picture.hpp>
#include <nana/gui/widgets/slider.hpp>
#include <nana/gui/widgets/spinbox.hpp>
#include <nana/gui/widgets/scroll.hpp>
#include <nana/gui/filebox.hpp>
#include <nana/gui/msgbox.hpp>
#include <nana/paint/graphics.hpp>

#ifdef _WIN32
#define WINONLY(x) x
#include <io.h>
#include <fcntl.h>
#else
#define WINONLY(x)
#endif

namespace fs = std::filesystem;
using std::vector;
using std::string_view;
using namespace nana;

// image metadata
struct pfm_header
{
    std::string magic;
    int w = 0, h = 0;
    float scale_endian;

    char get_magic2ndchar() const { return magic.length() >= 2 ? magic[1] : 0; }
    bool is_half() const { return tolower(get_magic2ndchar()) == 'h'; }
    bool is_mono() const { return islower(get_magic2ndchar()); }
    int num_channels() const { return is_mono() ? 1 : 3; }
    size_t calc_raw_size() const { return w * h * num_channels() * sizeof(float) / (is_half() ? 2 : 1); }
};

// check for input pipe, e.g: `$> PfmViewer.exe < file.pfm`
bool pending_data(std::istream& is)
{
    is.seekg(0, is.end);
    auto length = is.tellg();
    is.seekg(0, is.beg);
    return !(length < 0);
}

// one-liner helper
msgbox message(std::string const& title, msgbox::icon_t ico, msgbox::button_t btn)
{
    msgbox m({}, title, btn);
    m.icon(ico);
    return m;
}

// booleans to checkboxes
void data_bind(checkbox& cb, bool& data)
{
    cb.check(data);
    cb.events().click([&]() { data = cb.checked(); });
}

// using uint8 in ispc causes performance warnings so we use int8 on -128,127 range
// this function is the "signed to unsigned" remap
uint8_t stou(int8_t i)
{
    return uint8_t((int)i + 128);
}

size min(size const& a, size const& b)
{
    return {std::min(a.width, b.width), std::min(a.height, b.height)};
}

struct app_settings
{
    float exposure = 1.f;  // multiplier (not really EV)
    bool gamma = true;
    bool tone = true;
    bool flipy = false;
};

// do file prompting, or pipe/file parsing, and deserialize
void load_pfm_and_raw(int argc /*in*/, char* argv[] /*in*/, pfm_header& pfm /*out*/, vector<char>& raw /*out*/)
{
    std::istream* in = nullptr;
    fs::path inpath;
    std::ifstream infile;

    if ((argc >= 2 && argv[1][0] == '-') || pending_data(std::cin))  // input is piped on stdin?
    {
        in = &std::cin;
        in->rdbuf()->pubsetbuf(nullptr, 0);  // deactivate buffering otherwise the stream explodes with failbit after 3450 bytes read
    }
    else if (argc <= 1)  // no command line -> open file dialog
    {
        filebox picker{nullptr, true};
        picker.title("Pick image file");
        picker.add_filter("Portable half map (.phm)", "*.phm");
        picker.add_filter("Portable float map (.pfm)", "*.pfm");
        vector<fs::path> paths = picker.show();
        if (!paths.empty())
            inpath = paths[0];
    }
    else if (argc >= 2)
        inpath = argv[1];

    if (!inpath.empty())
    {
        infile.open(inpath, std::ifstream::in | std::ifstream::binary);
        in = &infile;
    }

    if (!in || !*in) throw std::exception("no good input");

    in->exceptions(std::ifstream::failbit | std::ifstream::badbit); // instant give up in case of issues

    *in >> pfm.magic >> pfm.w >> pfm.h >> pfm.scale_endian;

    std::cout << "magic:" << pfm.magic << " w:" << pfm.w << " h:" << pfm.h << " scale_endian: " << pfm.scale_endian << "\n";

    size_t alloc = pfm.calc_raw_size();
    if (alloc == 0)
    {
        (message("No data", msgbox::icon_information, msgbox::ok) << "Width and height are 0 or not found")();
        throw std::runtime_error("input data problem");
    }
    if (alloc > 1'000'000'000)
    {
        (message("Calculated image size too large", msgbox::icon_error, msgbox::ok)
         << "More than 1GiB of data needed because of parsed width:" << pfm.w << " and height:" << pfm.h)();
        throw std::runtime_error("input too big");
    }

    raw.resize(alloc);

    std::cout << "about to read " << alloc << " bytes\n";
    in->ignore(1);  // jump the last \n after scale_endian
    *in >> std::noskipws;
    in->clear();
    freopen(nullptr, "rb", stdin);  // go in binary mode from here
    WINONLY(_setmode(fileno(stdin), O_BINARY | O_RDONLY));
    // read bulk:
    in->sync();
    in->read(raw.data(), alloc);

    if (auto cnt = in->gcount(); cnt != alloc)
        std::cout << "not enough data read (" << cnt << " instead of " << alloc << " expected)\n";
    else if (std::cin.rdbuf()->in_avail() > 0)
        std::cout << "remaining data not read " << std::cin.rdbuf()->in_avail() << "\n";
    else
        std::cout << "success\n";
}

// Transform the HDR source image to a displayable SDR image
void raw_to_rgb(pfm_header const& pfm, vector<char> const& raw, vector<int8_t>& rgb /*out*/, app_settings const& state)
{
    // perform slow operations (pow, polynomials, divisions, minmax reduce...) using avx512 SIMD

    if (state.tone)
    {
        if (state.gamma)
        {
            if (pfm.is_half())
                ispc::ToneAllF16PixelsAndToGamma((uint16_t*)raw.data(), rgb.data(), raw.size() / 2, state.exposure);
            else
                ispc::ToneAllF32PixelsAndToGamma((float*)raw.data(), rgb.data(), raw.size() / 4, state.exposure);
        }
        else
        {
            if (pfm.is_half())
                ispc::ToneAllF16Pixels((uint16_t*)raw.data(), rgb.data(), raw.size() / 2, state.exposure);
            else
                ispc::ToneAllF32Pixels((float*)raw.data(), rgb.data(), raw.size() / 4, state.exposure);
        }
    }
    else
    {
        if (state.gamma)
        {
            if (pfm.is_half())
                ispc::GammaAllF16Pixels((uint16_t*)raw.data(), rgb.data(), raw.size() / 2);
            else
                ispc::GammaAllF32Pixels((float*)raw.data(), rgb.data(), raw.size() / 4);
        }
        else
        {
            if (pfm.is_half())
                ispc::ToSignedRgbAllF16Pixels((uint16_t*)raw.data(), rgb.data(), raw.size() / 2);
            else
                ispc::ToSignedRgbAllF32Pixels((float*)raw.data(), rgb.data(), raw.size() / 4);
        }
    }
}

// transfer signed-byte RGB image vector to a GUI-compatible surface
void rgb_to_graphics(pfm_header const& pfm, vector<int8_t> const& rgb, paint::graphics& surface)
{
    if (pfm.num_channels() == 3)
    {
        //#pragma omp parallel for schedule(static) // cannot be parallelized because .set_pixel is stateful and isn't using TLS
        for (int y = 0; y < pfm.h; ++y)
            for (int x = 0; x < pfm.w; ++x)
            {
                int8_t const* p = &rgb[3 * (y * pfm.w + x)];
                surface.set_pixel(x, y, {stou(p[0]), stou(p[1]), stou(p[2])});
            }
    }
    else
    {
        for (int y = 0; y < pfm.h; ++y)
            for (int x = 0; x < pfm.w; ++x)
            {
                uint8_t bw{stou(rgb[y * pfm.w + x])};
                surface.set_pixel(x, y, {bw, bw, bw});
            }
    }
}

std::pair<float, float> min_max(pfm_header const& pfm, vector<char> const& raw)
{
    float mi, ma;
    if (pfm.is_half())
        ispc::GetMinMaxF16((uint16_t*)raw.data(), raw.size() / 2, mi, ma);
    else
        ispc::GetMinMaxF32((float*)raw.data(), raw.size() / 4, mi, ma);
    return {mi, ma};
}

int main(int argc, char* argv[])
{
    pfm_header pfm;
    vector<char> raw;

    try
    {
        load_pfm_and_raw(argc, argv, pfm, raw);
    }
    catch (std::ios_base::failure& e)
    {
        (message("Exception in input stream", msgbox::icon_error, msgbox::ok) << e.what())();
        return 1;
    }
    catch (...)
    {
        return 2;
    }

    vector<int8_t> rgb;
    rgb.resize(pfm.w * pfm.h * pfm.num_channels());

    app_settings state;

    raw_to_rgb(pfm, raw, rgb, state);

    auto [rangemin, rangemax] = min_max(pfm, raw);

    paint::graphics surface(size(pfm.w, pfm.h));
    rgb_to_graphics(pfm, rgb, surface);

    // main window
    static const int initial_width_right_pane = 200;
    static const int initial_width_window = 1600;
    static const int initial_height_window = 1000;
    form mainwd{API::make_center(std::min(pfm.w, initial_width_window) + initial_width_right_pane,
                                 std::min(pfm.h, initial_height_window))};
    mainwd.caption("Silicon Studio PFM/PHM Viewer");
    // image zone:
    panel<false> panelZone{mainwd};
    picture pic{panelZone};
    nana::scroll<false> scrollH{panelZone};
    nana::scroll<true> scrollV{panelZone};
    auto resetAmounts = [&]()
    {
        scrollH.amount(std::max(0, pfm.w - (int)panelZone.size().width + 16));
        scrollV.amount(std::max(0, pfm.h - (int)panelZone.size().height + 16));
    };
    panelZone.events().resized(resetAmounts);
    place l2{panelZone};
    l2.div("<vert <<sub><scrollV weight=16>> <scrollH weight=16>>");
    l2["sub"] << pic;
    l2["scrollV"] << scrollV;
    l2["scrollH"] << scrollH;
    l2.collocate();
    drawing dr{pic};
    dr.draw([&](paint::graphics& a_g)
            {
                rectangle dst{{0,0}, min(panelZone.size(), a_g.size())};
                point src{(int)scrollH.value(), (int)scrollV.value()};
                a_g.bitblt(dst, surface, src);
            });
    scrollH.events().value_changed([&]() { API::refresh_window(pic); });
    scrollV.events().value_changed([&]() { API::refresh_window(pic); });
    // control panel zone:
    group opts_gp{mainwd, "Options"};
    data_bind(opts_gp.add_option("Gamma"), state.gamma);
    data_bind(opts_gp.add_option("Filmic tone"), state.tone);
    data_bind(opts_gp.add_option("Flip Y"), state.flipy);
    opts_gp.radio_mode(false);
    panel<false> ctrls{mainwd};
    place ctrlgrid{ctrls};
    label ev_lbl{ctrls};
    ev_lbl.caption("exposure:");
    slider ev_slider{ctrls};
    ev_slider.maximum(200);
    ev_slider.value(100);  // 1*100
    label maxev_lbl{ctrls};
    maxev_lbl.caption("ev-range max:");
    spinbox maxev_spin{ctrls};
    maxev_spin.range(0.0, 1000000.0, 0.1);
    maxev_spin.value("2");
    maxev_spin.events().text_changed([&]()
                                     {
                                         ev_slider.maximum(100 * maxev_spin.to_double());
                                     });
    ctrlgrid.div("<ctrlgrid grid=[2,2]>");
    ctrlgrid["ctrlgrid"] << ev_lbl << ev_slider << maxev_lbl << maxev_spin;
    ctrlgrid.collocate();
    label curexp_lbl{mainwd};
    auto refresh_curexp_lbl = [&]() {curexp_lbl.caption("EV: " + std::to_string(state.exposure)); };
    refresh_curexp_lbl();

    std::mutex m;
    std::condition_variable cv;
    bool dirty = false;
    bool quit = false;

    // we need a thread because HDC pixel transfer is slow
    auto image_recomputer = [&]()
    {
        for (;;)
        {
            {
                std::unique_lock lk(m);
                cv.wait(lk, [&] {return dirty || quit; });
                dirty = false;
                if (quit) return;
            }
            raw_to_rgb(pfm, raw, rgb, state);
            rgb_to_graphics(pfm, rgb, surface);
            API::refresh_window(pic);
        }
    };
    // use std thread. nana::thread::pool thing is horrendous and super slow. don't use it.
    std::thread worker(image_recomputer);

    ev_slider.events().value_changed([&]()
                                     {
                                         state.exposure = ev_slider.value() / 100.f;
                                         refresh_curexp_lbl();
                                         {
                                             std::lock_guard lk(m);
                                             dirty = true;
                                         }
                                         cv.notify_one();
                                     });
    label info{mainwd};
    info.caption("source range: " + std::to_string(rangemin) + ", " + std::to_string(rangemax));
    place layout{mainwd};
    layout.div("<picdisplay>|200<vert controls arrange=[100,64,24,24]>");
    layout["picdisplay"] << panelZone;
    layout["controls"] << opts_gp << ctrls << curexp_lbl << info;
    layout.collocate();

    mainwd.show();
    exec();

    // stop the refresher thread otherwise we get an assert in the CRT
    {
        std::lock_guard lk(m);
        quit = true;
    }
    cv.notify_one();
    worker.join();

    return 0;
}
